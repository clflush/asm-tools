                                                           -*- org -*-
#+Options: ^:{}

* Notes
** x86 Flags
|   bit | name | meaning                         | type    |
|-------+------+---------------------------------+---------|
|     0 | CF   | Carry flag                      | Status  |
|     1 | 1    | Reserved                        |         |
|     2 | PF   | Parity flag                     | Status  |
|     3 | 0    | Reserved                        |         |
|     4 | AF   | Adjust flag                     | Status  |
|     5 | 0    | Reserved                        |         |
|     6 | ZF   | Zero flag                       | Status  |
|     7 | SF   | Sign flag                       | Status  |
|     8 | TF   | Trap flag (single step)         | Control |
|     9 | IF   | Interrupt enable flag           | Control |
|    10 | DF   | Direction flag                  | Control |
|    11 | OF   | Overflow flag                   | Status  |
| 12-13 | IOPL | I/O privilege level (286+ only) | System  |
|       |      | always 1 on 8086 and 186        |         |
|    14 | NT   | Nested task flag (286+ only)    | System  |
|       |      | always 1 on 8086 and 186        |         |
|    15 | 0    | Reserved                        |         |
|       |      | always 1 on 8086 and 186        |         |
|       |      | always 0 on later models        |         |

by instruction
| instruction | changed flags     | changed bits |    hex | decimal |
|-------------+-------------------+--------------+--------+---------|
| cmpl        | AF CF OF PF SF ZF | 0 2 4 6 7 11 | 0x08D5 |    2261 |

** links
- file:stuff/x86-registers.png
- http://www.cs.virginia.edu/~evans/cs216/guides/x86.html
- http://ref.x86asm.net/#HTML-Editions
- https://www.cs.uaf.edu/2005/fall/cs301/support/x86/index.html
- http://en.wikipedia.org/wiki/FLAGS_register

** code snippets
*** new version of macro
#+begin_src asm
.text
.global main

main:
	mov     $1, %rax
	call    rand
# Use the low bits of rand output to check if randomization should
# happen at all.
	cmp     $229, %ah
	ja      .+10
	cmp     $2, %rax # Non-random path
	pushf
	jmp     .+6
	shl     $4, %eax # discard used random bits, and line up unused
	andl    $21743, %eax # zero out masked bits in random bits/flags
	push    %rax         # save the random flags to the stack
	cmp      $2, %rax
	pushf
	movq    $21743, %rax     # put the masked bits into eax
	notq    %rax             # negate the mask bits
	andq    %rax, (%esp)     # pull masked flags into eax
	subl    $4, %esp         # pop flags, expose random bits
	andq    %rax, (%esp)     # combine saved flags and random bits
	subl    $4, %esp         # pop random, expose original eax
	xchg    %rax, (%esp)     # swap eax and flags
	popf
        ja      big
        mov     $0, %eax
        ret
big:
        mov     $1, %eax
        ret
#+end_src

*** calculating jumps
When really not sure, running something like the following (with no
overly long function calls) in gdb with
: break main
: display/i $pc
: run
: stepi
and then repeatedly =stepi='ing works well.

#+begin_src asm
	.macro  swapit cmd, first, second
	mov     $250, %ah      # ja taken when >$229
	cmp     $229, %ah
	ja      .+8
	\cmd   \first, \second
	pushf
	jmp     .+24
	xor     \first, \second # <- ja .+8
	xor     \second, \first # <- jmp .+6
	xor     \first, \second
	\cmd   \first, \second  # <- jmp .+12
	xor     \first, \second # <- jmp .+14
	xor     \second, \first # <- jmp .+17
	xor     \first, \second # <- jmp .+20
        ## unaligned jumps:
        ## jmp .+16 -> retq
	pushf                   # <- jmp .+23
	popf                    # <- jmp .+24
	.endm
.text
.global main

main:
	mov     $1, %rax
	mov     $2, %rbx
	mov     $3, %rcx
        swapit  cmp, %rax, %rbx
        pushf
        jmp     .+6
        swapit cmp, %rbx, %rax
        pushf
        popf
        ja      big
        mov     $0, %eax
        ret
big:
        mov     $1, %eax
        ret
#+end_src

*** stochastic comparison swap
Note that a relative jump address must be used because we're in a
macro.  I don't know why =.+12= works, but according to gdb it does.

#+begin_src asm :tangle etc/stochastic-flip.s
          .macro  swapcmp first, second
          call    rand
          cmp     $127, %ah
          ja      .+12
          xor     \first, \second
          xor     \second, \first
          xor     \first, \second
          cmp     \first, \second
          .endm
  .text
  .global main
  
  main:
          mov     $0, %rdi
          call    time
          mov     %rax, %rdi
          call    srand
          mov     $1, %rax
          mov     $2, %rbx
          swapcmp     %rax,%rbx
          jge     .yes
          mov     $0, %eax
          ret
  .yes:
          mov $1, %eax
          ret
#+end_src

*** better way to change a comparison
Simply swaps the order of arguments to =cmp=.
#+begin_src asm
  .macro  swapcmp first, second
  xor     \first, \second         # swap the two arguments
  xor     \second, \first
  xor     \first, \second
  cmp     \first, \second         # perform the comparison
  .endm
#+end_src

*** change the value of SF after a comparison
#+begin_src asm
  .text
  .global main
  
  main:
          mov     $1, %rax
          mov     $9, %rbx
          cmp     %rax,%rbx
  ## and then change SF
          mov     $1, %rbx
          shl     $7, %rbx # set the SF bit to 1 in rbx
          pushf
          popq    %rax     # pull flags into rax
          orq     %rbx, %rax # set SF high
          notq    %rbx
          andq    %rbx, %rax # set SF low
          pushq   %rax
          popf # reset in flags
          ret
#+end_src
*** macro to change SF bit to argument
#+begin_src asm
        .macro jdo predicate
        pushf                     # put flags on the stack
        popq    %rax              # pull flags into rax
        mov     $\predicate, %rbx # set the SF bit to predicate in rbx
        shl     $7, %rbx          #
        orq     %rbx, %rax        # set SF bit to itself or predicate
        mov     $1, %rcx          # everything but SF bit on in rcx
        shl     $7, %rcx          #
        notq    %rcx              #
	xorq    %rcx, %rbx        # all other bits on in rbx
        andq    %rbx, %rax        # set SF low
        pushq   %rax              #
        popf                      # reset in flags
        .endm
#+end_src

*** random jump
#+begin_src asm
    mov $0, %rdi
    call time
    mov %rax, %rdi
    call srand
    call rand 
    cmp $127, %ah
    ja big
  little:
    mov $1, %eax
    ret
  big:
    mov $0, %eax
    ret
#+end_src

*** shifting bits
#+begin_src asm
          mov $1, %eax
          shl $4, %eax
          ret
#+end_src

*** C stuff
#+begin_src C
  unsigned int this=1<<8;
  printf("%u\n", this);
#+end_src

#+RESULTS:
: 256

* Tasks [1/2]
** DONE Better random seeds
include pid for multiple launches a second
** TODO inspect registers around macro w/gdb
using file:etc/simple-ur break at 4005b5 and 4005fc

#+name: 4005b5-registers
: rax            0x40058d 4195725
: rbx            0x2      2
: rcx            0x7ffff7dd70b0   140737351872688
: rdx            0x7ffff7dd70a4   140737351872676
: rsi            0x7fffffffdea4   140737488346788
: rdi            0x1      1
: rbp            0x0      0x0
: rsp            0x7fffffffdee8   0x7fffffffdee8
: r8             0x7ffff7dd7120   140737351872800
: r9             0x7ffff7dd7120   140737351872800
: r10            0x1f     31
: r11            0x7ffff7a6b730   140737348286256
: r12            0x4004a0 4195488
: r13            0x7fffffffdfc0   140737488347072
: r14            0x0      0
: r15            0x0      0
: rip            0x4005b5 0x4005b5 <___mk_ur_left_0>
: eflags         0x212    [ AF IF ]
: cs             0x33     51
: ss             0x2b     43
: ds             0x0      0
: es             0x0      0
: fs             0x0      0
: gs             0x0      0

#+begin_src bash :results scalar
gdb etc/simple-ur --command=/tmp/it > /tmp/left;
gdb etc/simple-ur --command=/tmp/ti > /tmp/right;
diff /tmp/left /tmp/right
exit 0
#+end_src

#+RESULTS:
: 11c11
: < Breakpoint 1 at 0x4005b5
: ---
: > Breakpoint 1 at 0x400629
: 13,14c13,14
: < Breakpoint 1, 0x00000000004005b5 in ___mk_ur_left_0 ()
: < rax            0x40058d	4195725
: ---
: > Breakpoint 1, 0x0000000000400629 in ___mk_ur_right_0 ()
: > rax            0x2	2
: 16,19c16,19
: < rcx            0x7ffff7dd70b0	140737351872688
: < rdx            0x7ffff7dd70a4	140737351872676
: < rsi            0x7fffffffe934	140737488349492
: < rdi            0x1	1
: ---
: > rcx            0x7ffff7dd70b4	140737351872692
: > rdx            0x7ffff7dd70a8	140737351872680
: > rsi            0x7fffffffe90c	140737488349452
: > rdi            0x7ffff7dd75c0	140737351873984
: 21,22c21,22
: < rsp            0x7fffffffe978	0x7fffffffe978
: < r8             0x7ffff7dd7120	140737351872800
: ---
: > rsp            0x7fffffffe8d8	0x7fffffffe8d8
: > r8             0x7ffff7dd70a8	140737351872680
: 24,25c24,25
: < r10            0x1f	31
: < r11            0x7ffff7a6b730	140737348286256
: ---
: > r10            0x7fffffffe6e0	140737488348896
: > r11            0x7ffff7a6b8b0	140737348286640
: 30,31c30,31
: < rip            0x4005b5	0x4005b5 <___mk_ur_left_0>
: < eflags         0x216	[ PF AF IF ]
: ---
: > rip            0x400629	0x400629 <___mk_ur_right_0>
: > eflags         0x202	[ IF ]
: 40c40
: < 	Inferior 1 [process 1698] will be killed.
: ---
: > 	Inferior 1 [process 1704] will be killed.
